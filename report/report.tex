\documentclass[12pt]{report}

\usepackage[letterpaper, hmargin=0.75in, vmargin=0.75in]{geometry}

\usepackage{
    courier,
    algorithm,
    algpseudocode,
    listings,
    underscore,
    authblk,
    hyperref,
    tikz,
    tabularx,
    float,
    graphicx,
	 color
}

\lstset{basicstyle=\footnotesize\ttfamily}

\setlength{\parindent}{0pt}

\begin{document}

\title{RTX Software Design Report}

\author{
    Clement Hoang\\
		20531116\\
    \texttt{c8hoang@uwaterloo.ca}
    \and
    David Su\\
		20516776\\
    \texttt{dysu@uwaterloo.ca}
    \and
    Cole Vander Veen\\
		20503626\\
    \texttt{cgvander@waterloo.ca}
    \and
    Peter Li\\
		XXXXXXXXX\\
    \texttt{y648li@uwaterloo.ca}
}

\date{Winter 2016}

\maketitle


\tableofcontents
\listofalgorithms
\listoffigures

\chapter{Introduction}

The purpose of this report is to outline the design of the RTX written by the group members, Clement Hoang, David Su, Peter Li, and Cole Vander Veen, as part of the SE350 course at the University of Waterloo. The OS is designed for a Keil MCB1700 Cortex-M3 board, with a LPC1768 microcontroller.

It is aimed to provide documentation for the operating system, in order to facilitate the use and understanding for anyone interested in programming for the OS. As such, this report outlines the global variables used in the OS, and then moves on to describing the kernel API in a modular and chronological way, from when we implemented it. Finally, the report closes with some analysis on the OS, and challenges that the group faced for the duration of the lab.

\chapter{Design Description}

\section{Data Structures}
\begin{itemize}
  \item \texttt{MemBlock}: a node that represents a block of memory, with its size defined by the global, \texttt{BLOCK_SIZE}
  \item \texttt{MemQueue}: a data structure which models the physical memory available to the OS, using a linked list of \texttt{MemBlock} nodes.

  \item \texttt{PCB}
  \item \texttt{PCBQ}
  \item \texttt{envelope}
  \item \texttt{gp_pcbs}
\end{itemize}

\section{Global Variables}
\begin{itemize}
  \item \texttt{memQueue}:
  \item \texttt{gp_pcbs}:
  \item \texttt{gp_stack}
  \item \texttt{p_end}
  \item \texttt{numOfBlocks}
\end{itemize}

\section{Memory Management}

\subsection{Memory Structure}

dsfdasfdsafdsafdsafsadfdsaf

\begin{figure}
	\includegraphics{memory.png}
\caption{Memory Layout}

\end{figure}

\subsection{Requesting Memory Blocks}

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C, frame=single]
int k_request_memory_block(void);
\end{lstlisting}
\end{minipage}

describe input, output, effects

\begin{algorithm}
  \caption{k_request_memory_block}
  \begin{algorithmic}[1]
    \Procedure{request\_memory\_block}{}
      \While{heap is full}
			\State {block the current process}
	  \EndWhile
	  \State {update the free space list}
	  \State {return the address of the top of the block}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{Releasing Memory Blocks}

\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C, frame=single]
int k_release_memory_block(void* memory_block);
\end{lstlisting}
\end{minipage}

describe input, output, effects

\begin{algorithm}
  \caption{The memory release function}
  \begin{algorithmic}[1]
    \Procedure{release\_memory\_block}{*memory_block}
      \If{this block is the top block of the heap}
			\State {modify heap header node (never gets overwritten)}
	  \EndIf
	  \If{there is free space immediately beneath this block}
			\State {combine them by increasing this block's length}
	  \Else { this block becomes a new block node, is added to the list}
	  \EndIf
	  \If{there is free space immediately beneath this block}
			\State {combine them by increasing this block's length}
	  \EndIf
	  \If{a process is blocked on memory}
			\State {unblock that process, release the processor}
	  \EndIf
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\pagebreak


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Processor Management}

\subsection{Process Control Structures}
DFASFAFD

\subsection{Process Queues}

fsadfasdfadsf

\subsection{Process Scheduling}
sdfasdfasdfdasf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Process Priority Management}

\subsection{Get Process Priority}

asdfadsfasf

\subsection{Set Process Priority}

dsfasdfasfsfdf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Interprocess Communication}

\subsection{Message Structure}

dsfadsfadsfdasfdafs

\subsection{Sending Messages}

adsfdsafasdfasf

\subsection{Receiving Messages}

dsfafasfdasf

\subsection{Delayed Send}


sdfasfasfd

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Interrupts and I-Processes}

\subsection{UART I-Process}

dsfadsfadsfadsf

\subsection{Timer I-Process}

sdfasfdafd

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{System Processes}

\subsection{Null Process}

sdfdasfafadsf

\subsection{CRT Process}

sdfdsfafaf

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{User Processes}

\subsection{Wall Clock Process}

sdfasdfafadf

\subsection{Set Priority Process}

dsfasdfasdfadsf

\subsection{Stress Test Processes}

dfdasfasdfads

\section{Initialization}

dasfasfasfd

\section{Testing}

dfadsfasdf

\section{Major Design Changes}

dsfdafadsf

\chapter{Lessons Learned}

\section{Source Control and Code Management}

sdfdsafsadf

\chapter{Team Dynamics and Individual Responsibilities}

\section{adsfadsf}

dfasfasdf

\chapter{Timing Analysis}

\end{document}
